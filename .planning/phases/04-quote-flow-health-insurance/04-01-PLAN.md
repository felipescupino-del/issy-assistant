---
phase: 04-quote-flow-health-insurance
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/data/healthQuoteMock.ts
  - src/services/quoteService.ts
autonomous: true
requirements: [QUOT-01, QUOT-02, QUOT-03, QUOT-04]

must_haves:
  truths:
    - "QuoteState interface exists with status, currentStep, retryCount, and 4 nullable collected fields (lives, ageRange, city, planType)"
    - "isQuoteState type guard correctly identifies valid QuoteState objects and rejects null/malformed values"
    - "Mock health plan data provides operator name, plan name, coverages, carencia, and base price for quote output"
    - "quoteService exports handleQuoteMessage as the single entry point for all quote interactions"
    - "Each of the 4 field step handlers extracts and validates input, advances state on success, retries with escalating messages on failure (max 3)"
    - "City normalization resolves aliases (sp, rj, bh, cwb, poa) and accent-insensitive input to canonical city names"
    - "Confirmation step builds a human-readable summary of all 4 collected fields and asks for approval"
    - "Quote output message uses WhatsApp formatting with emojis, bold, and line breaks showing plan details, coverages, carencias, and mocked price"
    - "QuoteState is persisted to Conversation.state (JSONB) via Prisma on every step transition"
  artifacts:
    - path: "src/types/index.ts"
      provides: "QuoteState interface and QuoteStep type"
      contains: "QuoteState"
    - path: "src/data/healthQuoteMock.ts"
      provides: "Mock health insurance plan data for quote output"
      contains: "HealthQuotePlan"
    - path: "src/services/quoteService.ts"
      provides: "Quote flow state machine — handleQuoteMessage entry point, step handlers, extraction, retry, formatter"
      exports: ["handleQuoteMessage", "getQuoteState"]
  key_links:
    - from: "src/services/quoteService.ts"
      to: "src/types/index.ts"
      via: "imports QuoteState, QuoteStep"
      pattern: "import.*QuoteState.*from"
    - from: "src/services/quoteService.ts"
      to: "src/data/healthQuoteMock.ts"
      via: "imports mock plan data for quote output"
      pattern: "import.*healthQuoteMock"
    - from: "src/services/quoteService.ts"
      to: "prisma.conversation"
      via: "reads/writes Conversation.state as QuoteState"
      pattern: "prisma\\.conversation\\.(findUnique|update)"
    - from: "src/services/quoteService.ts"
      to: "src/services/whatsapp.ts"
      via: "sends step prompts and quote output via sendTextMessage"
      pattern: "sendTextMessage"
---

<objective>
Build the complete quote flow service — types, mock data, and state machine dispatcher with all field handlers, validation, retry logic, and quote output formatter.

Purpose: This is the core engine of Phase 4. It implements the health insurance quote flow as a hand-rolled state machine persisted to JSONB. Once built, Plan 02 wires it into the webhook pipeline.

Output: Three files — QuoteState types in types/index.ts, mock plan data in healthQuoteMock.ts, and the complete quoteService.ts with handleQuoteMessage entry point.
</objective>

<execution_context>
@/Users/felipescupino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/felipescupino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quote-flow-health-insurance/04-RESEARCH.md
@.planning/phases/04-quote-flow-health-insurance/04-CONTEXT.md

@src/types/index.ts
@prisma/schema.prisma
@src/services/whatsapp.ts
@src/services/history.ts
@src/services/ai.ts
@src/lib/prisma.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QuoteState types and create mock health plan data</name>
  <files>src/types/index.ts, src/data/healthQuoteMock.ts</files>
  <action>
**1. Extend src/types/index.ts** — add at the bottom (preserve all existing exports):

```typescript
// Quote flow types — Phase 4
export type QuoteStep = 'lives' | 'age_range' | 'city' | 'plan_type' | 'confirm' | 'done';

export interface QuoteState {
  status: 'collecting' | 'confirming' | 'complete' | 'abandoned';
  currentStep: QuoteStep;
  retryCount: number;           // retries on current field (max 3)
  lives: number | null;
  ageRange: string | null;      // e.g. "25-35"
  city: string | null;          // one of ALLOWED_CITIES
  planType: 'enfermaria' | 'apartamento' | null;
  startedAt: string;            // ISO timestamp
  updatedAt: string;            // ISO timestamp
}
```

**2. Create src/data/healthQuoteMock.ts** — mock operator data for demo:

Define a `HealthQuotePlan` interface and export a single mock plan object (not an array — CONTEXT.md says "1 plano mockado por cotacao"). Use fictional operator name (e.g. "Saude Segura") and plan name (e.g. "Essencial Plus"). Include:
- `operator: string` — fictional operator name
- `planName: string` — fictional plan name
- `coverages: string[]` — 5-6 common health coverage items (consultas, internacao, exames, pronto-socorro, cirurgias, quimioterapia)
- `carpiod: Record<string, string>` — carencia by category: `{ urgencias: '30 dias', cirurgias: '180 dias', partos: '300 dias' }`
- `baseMonthlyPrice: number` — base price per person for enfermaria (e.g. 280)
- `apartamentoMultiplier: number` — multiplier for apartamento tier (e.g. 1.4)
- `ageMultipliers: Record<string, number>` — age band multipliers: `{ '0-18': 0.7, '19-23': 0.8, '24-28': 0.9, '29-33': 1.0, '34-38': 1.1, '39-43': 1.2, '44-48': 1.4, '49-53': 1.6, '54-58': 1.9, '59+': 2.3 }`

Export the plan as `export const HEALTH_PLAN: HealthQuotePlan = { ... }`.

Also export `ALLOWED_CITIES` as a string array: `['Sao Paulo', 'Rio de Janeiro', 'Belo Horizonte', 'Curitiba', 'Porto Alegre']`.

NOTE: All values are fictional for demo. Use concrete, realistic-looking numbers that will impress in a demo but are clearly not real pricing.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Check that QuoteState type and HealthQuotePlan data are correctly defined</manual>
  </verify>
  <done>QuoteState/QuoteStep types exported from types/index.ts. HealthQuotePlan with realistic mock data exported from healthQuoteMock.ts. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create quoteService.ts — state machine dispatcher with all step handlers</name>
  <files>src/services/quoteService.ts</files>
  <action>
Create `src/services/quoteService.ts` — the complete quote flow service. This is the core engine of Phase 4. All quote interactions flow through `handleQuoteMessage`.

**Imports needed:**
- `{ prisma }` from `../lib/prisma`
- `{ QuoteState, QuoteStep }` from `../types/index`
- `{ HEALTH_PLAN, ALLOWED_CITIES, HealthQuotePlan }` from `../data/healthQuoteMock`
- `{ sendTextMessage, computeDelaySeconds }` from `./whatsapp`
- `{ saveMessage }` from `./history`
- `{ config }` from `../config`
- `OpenAI` from `openai`

**State helpers (internal):**

1. `isQuoteState(value: unknown): value is QuoteState` — type guard. Check `value` is non-null object with `status` (string), `currentStep` (string), `retryCount` (number). Return false for null/undefined/non-object.

2. `createFreshQuoteState(): QuoteState` — returns new state with `status: 'collecting'`, `currentStep: 'lives'`, `retryCount: 0`, all fields null, `startedAt`/`updatedAt` as `new Date().toISOString()`.

3. `getQuoteState(phone: string): Promise<QuoteState | null>` — EXPORTED. Read `Conversation.findUnique({ where: { phone } })`, return `isQuoteState(conv?.state) ? (conv!.state as unknown as QuoteState) : null`. Must handle null conversation (return null).

4. `persistQuoteState(phone: string, state: QuoteState): Promise<void>` — update `updatedAt`, then `prisma.conversation.update({ where: { phone }, data: { state: state as unknown as Prisma.InputJsonObject } })`. Import `Prisma` from generated client for the cast.

**Step prompt templates:**
Define `STEP_PROMPTS: Record<QuoteStep, string>` with:
- `lives`: Greeting + ask how many lives (ex: 1, 3, 10)
- `age_range`: Ask age range of beneficiaries (ex: 20-30, 35-45, 50-60)
- `city`: Ask city + list available cities (Sao Paulo, Rio de Janeiro, Belo Horizonte, Curitiba, Porto Alegre)
- `plan_type`: Ask accommodation type — 1) Enfermaria 2) Apartamento
- `confirm`: empty string (built dynamically)
- `done`: empty string (built dynamically)

Use WhatsApp formatting per CONTEXT.md: emojis, *bold*, clear prompts. Friendly professional tone ("Perfeito! Agora me diz...").

**Retry messages:**
`getRetryMessage(field: QuoteStep, attempt: number): string` — 3 escalating messages per field:
- attempt 1: gentle rephrase
- attempt 2: very specific instruction ("Me diz somente o numero, por exemplo: *4*")
- attempt 3: offer to skip or transfer to human ("Quer pular essa pergunta e falar com um consultor?")

**Value extraction functions (internal):**

1. `extractLivesCount(text: string): Promise<number | null>` — fast path: regex `\b(\d+)\b` for pure numeric. Slow path: GPT extraction with system prompt "Voce extrai o numero de vidas de um texto em portugues. Responda APENAS com um numero inteiro ou NENHUM." Temperature 0, max_tokens 10. Return parsed int or null.

2. `extractAgeRange(text: string): Promise<string | null>` — fast path: regex for patterns like "20-30", "20 a 30", "entre 20 e 30". Normalize to "XX-YY" format. Slow path: GPT extraction with prompt to return age range in "XX-YY" format. Validate: min age >= 0, max age <= 120, min < max.

3. `resolveCity(input: string): string | null` — NO GPT needed. Build `CITY_ALIASES: Record<string, string>` mapping lowercase/accent-stripped aliases to canonical names. Include: "sp" -> "Sao Paulo", "sao paulo" -> "Sao Paulo", "rio" -> "Rio de Janeiro", "rj" -> "Rio de Janeiro", "bh" -> "Belo Horizonte", "belo horizonte" -> "Belo Horizonte", "cwb" -> "Curitiba", "curitiba" -> "Curitiba", "poa" -> "Porto Alegre", "porto alegre" -> "Porto Alegre", plus accented variants. Normalize input: `toLowerCase().trim().normalize('NFD').replace(/[\u0300-\u036f]/g, '')`.

4. `resolvePlanType(input: string): 'enfermaria' | 'apartamento' | null` — NO GPT. Match "1", "enfermaria" -> 'enfermaria'. Match "2", "apartamento", "apto" -> 'apartamento'. Case-insensitive.

**Step handlers (internal async functions):**
Each handler follows the same pattern:
1. Extract value from `text` using the appropriate extractor
2. If extracted successfully: set field on state, advance `currentStep` to next step, reset `retryCount` to 0, persist state, send next step prompt (or confirmation summary for the last field)
3. If extraction fails: increment `retryCount`, persist state, send retry message via `sendTextMessage`. If `retryCount >= 3` and user answers "sim" to transfer offer, abandon quote and trigger handoff hint.

Handlers:
- `handleLivesStep(phone, text, state)` — validate: lives >= 1 and <= 100. After success, advance to 'age_range'.
- `handleAgeRangeStep(phone, text, state)` — after success, advance to 'city'.
- `handleCityStep(phone, text, state)` — use `resolveCity()`. On failure, list available cities in error message. After success, advance to 'plan_type'.
- `handlePlanTypeStep(phone, text, state)` — use `resolvePlanType()`. After success, advance to 'confirm', set `status: 'confirming'`.

**Confirmation handler:**
`handleConfirmStep(phone, text, state)` — parse "sim"/"correto"/"ok"/"yes"/"1" as approval. Parse "nao"/"errado"/"corrigir"/"2" as rejection. On approval: set `status: 'complete'`, `currentStep: 'done'`, persist state, call `buildQuoteMessage(state)` and send. On rejection: check if user specifies which field to correct (e.g., "cidade errada" -> go back to 'city' step only, preserving other fields). If ambiguous rejection, reset to 'lives' and start over. Per CONTEXT.md: "sem perder dados ja coletados" when correcting specific field.

**Confirmation summary builder:**
`buildConfirmationMessage(state: QuoteState): string` — format all 4 collected fields in WhatsApp format:
```
Vou confirmar os dados da cotacao:

*Vidas:* {lives}
*Faixa etaria:* {ageRange} anos
*Cidade:* {city}
*Acomodacao:* {planType}

Esta tudo correto? Responda *sim* para gerar a cotacao ou *nao* para corrigir.
```

**Quote output builder:**
`buildQuoteMessage(state: QuoteState): string` — use mock data from `HEALTH_PLAN`. Calculate price: `baseMonthlyPrice * lives * apartamentoMultiplier (if apt) * ageMultiplier`. Find closest age band from `ageMultipliers` using the midpoint of the ageRange. Format per CONTEXT.md spec:
```
hospital emoji *Plano de Saude -- Cotacao*

*Operadora:* {operator}
*Plano:* {planName}
*Acomodacao:* {planType display}

checkmark emoji *Coberturas incluidas:*
- {each coverage}

hourglass emoji *Carencias:*
- 30 dias: urgencias e emergencias
- 180 dias: cirurgias eletivas
- 300 dias: partos

money emoji *Valor estimado:* R$ {total}/mes
_({lives} vida(s) | faixa {ageRange} anos | {city} | {planType display})_

---
Quer cotar outro plano? Ou prefere falar com um consultor?
```

Use actual emoji characters (hospital, checkmark, hourglass, money bag) per CONTEXT.md locked decision.

**Main entry point (EXPORTED):**
`handleQuoteMessage(phone: string, text: string, existingState: QuoteState | null): Promise<void>`

Logic:
1. If `existingState` is null or status is 'complete'/'abandoned' — start fresh: create new state, persist, send `STEP_PROMPTS.lives`, save assistant message, return.
2. If `existingState.status === 'collecting'` — dispatch to step handler based on `currentStep`.
3. If `existingState.status === 'confirming'` — dispatch to `handleConfirmStep`.

Every `sendTextMessage` call uses `computeDelaySeconds()` for the delay parameter.
Every sent message is followed by `saveMessage(phone, 'assistant', messageText)` — save AFTER send succeeds (project invariant).

IMPORTANT patterns from existing codebase:
- Import `{ Prisma }` from `../generated/prisma` for `Prisma.InputJsonObject` cast on state write
- Use `config.openai.model` for GPT extraction calls (not hardcoded model name)
- Use console.log with `[quoteService]` prefix for logging
- Follow save-after-send pattern established in Phase 2
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Verify quoteService.ts exports handleQuoteMessage and getQuoteState, contains all 4 step handlers, retry logic, and quote formatter</manual>
  </verify>
  <done>quoteService.ts exports handleQuoteMessage (entry point) and getQuoteState (state reader). Contains: state helpers (create, persist, read, type guard), 4 field step handlers with extraction + validation + retry, confirmation handler with field-level correction, quote output builder with WhatsApp formatting and mocked pricing, step prompt templates. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. `src/types/index.ts` exports QuoteState and QuoteStep types
3. `src/data/healthQuoteMock.ts` exports HEALTH_PLAN with all required fields and ALLOWED_CITIES
4. `src/services/quoteService.ts` exports handleQuoteMessage and getQuoteState
5. quoteService.ts imports from types, mock data, whatsapp, history, config, and prisma — all resolve correctly
</verification>

<success_criteria>
- QuoteState type and HealthQuotePlan mock data are defined and compilable
- quoteService.ts contains the complete state machine: state helpers, step handlers for all 4 fields, confirmation handler, retry logic, extraction functions, quote output builder
- All files compile cleanly with `npx tsc --noEmit`
- No files from Plan 02 are touched (webhook.ts, ai.ts remain unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/04-quote-flow-health-insurance/04-01-SUMMARY.md`
</output>
