---
phase: 03-insurance-qa-handoff
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/insuranceFacts.ts
  - src/services/ai.ts
  - src/routes/webhook.ts
  - src/types/index.ts
autonomous: true
requirements: [KNOW-01, KNOW-02, KNOW-03, KNOW-04]

must_haves:
  truths:
    - "Bot receives a question about saúde and responds with grounded facts about health insurance coverages"
    - "Bot receives a question about auto/vida/residencial/empresarial and responds with product-specific facts"
    - "Bot responds about coverage inclusions, exclusions, and acceptance rules with hedging qualifiers (not invented values)"
    - "Bot maintains professional, concise tone in Portuguese when answering insurance questions"
    - "Bot receives a general non-product question and responds without injecting any product facts block"
  artifacts:
    - path: "src/data/insuranceFacts.ts"
      provides: "Insurance facts organized by product type with ASSESSORIA markers for placeholder values"
      exports: ["insuranceFacts", "ProductType", "InsuranceFacts"]
    - path: "src/services/ai.ts"
      provides: "Updated system prompt with dynamic product facts injection"
      exports: ["generateResponse"]
    - path: "src/types/index.ts"
      provides: "ProductType and InsuranceFacts types"
      contains: "ProductType"
  key_links:
    - from: "src/routes/webhook.ts"
      to: "src/services/ai.ts"
      via: "detectProductType(text) result passed to generateResponse()"
      pattern: "detectProductType.*generateResponse"
    - from: "src/services/ai.ts"
      to: "src/data/insuranceFacts.ts"
      via: "insuranceFacts[productType] lookup in buildSystemPrompt"
      pattern: "insuranceFacts\\[.*\\]"
---

<objective>
Add the insurance knowledge layer so the bot answers product-specific questions using curated facts injected into the system prompt at runtime.

Purpose: KNOW-01 through KNOW-04 — the bot must answer questions about 5 insurance product types (saude, auto, vida, residencial, empresarial) with grounded facts about coverages, exclusions, and acceptance rules, using professional tone in Portuguese. Facts are hedged with [ASSESSORIA] markers for placeholder values to prevent hallucination.

Output: `src/data/insuranceFacts.ts` (facts file), updated `src/services/ai.ts` (dynamic prompt injection), updated `src/routes/webhook.ts` (product detection wiring), updated `src/types/index.ts` (shared types).
</objective>

<execution_context>
@/Users/felipescupino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/felipescupino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-insurance-qa-handoff/03-RESEARCH.md

@src/services/ai.ts
@src/routes/webhook.ts
@src/services/intent.ts
@src/types/index.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create insurance facts data file and product detection</name>
  <files>src/data/insuranceFacts.ts, src/types/index.ts</files>
  <action>
1. Update `src/types/index.ts` — add these types AFTER the existing `ConversationContext` interface:

```typescript
export type ProductType = 'saude' | 'auto' | 'vida' | 'residencial' | 'empresarial';

export interface InsuranceFacts {
  productName: string;
  description: string;
  commonCoverages: string[];
  commonExclusions: string[];
  acceptanceRules: string[];
  importantNotes: string[];
}
```

2. Create `src/data/insuranceFacts.ts` — export a `Record<ProductType, InsuranceFacts>` with curated content for all 5 product types. Also export a `detectProductType(text: string): ProductType | null` function in the same file (no need for a separate productDetector.ts — the function is ~15 lines and colocating keeps the knowledge layer self-contained).

**Product detection keywords** (use `text.toLowerCase()` matching):
- `saude`: 'saúde', 'saude', 'plano de saúde', 'médico', 'medico', 'hospitalar'
- `auto`: 'auto', 'automóvel', 'automovel', 'carro', 'veículo', 'veiculo', 'frota'
- `vida`: 'vida', 'morte', 'funeral', 'seguro de vida'
- `residencial`: 'residencial', 'casa', 'apartamento', 'imóvel', 'imovel', 'residência', 'residencia'
- `empresarial`: 'empresarial', 'empresa', 'negócio', 'negocio', 'comercial', 'cnpj'

**Facts content rules:**
- Each product has realistic general-knowledge facts (not invented specific R$ values)
- All placeholder values that require assessoria confirmation use the marker: `[ASSESSORIA: description]`
- All `importantNotes` entries include a hedging statement like "Valores e carências variam por seguradora — consulte a tabela atualizada"
- Write all facts content in Portuguese brasileiro
- `commonCoverages`: 4-6 items per product
- `commonExclusions`: 3-4 items per product
- `acceptanceRules`: 2-3 items per product
- `importantNotes`: 1-2 items per product

Import `ProductType` and `InsuranceFacts` from `../types/index`.
  </action>
  <verify>
    <automated>npx tsc --noEmit --skipLibCheck 2>&1 | head -20</automated>
    <manual>Inspect insuranceFacts.ts has all 5 products, each with non-empty arrays for all 4 fact categories</manual>
  </verify>
  <done>
- `src/types/index.ts` exports ProductType and InsuranceFacts
- `src/data/insuranceFacts.ts` exports insuranceFacts (Record with 5 products) and detectProductType function
- All 5 products have non-empty coverages, exclusions, acceptanceRules, importantNotes arrays
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire product facts into AI service and webhook pipeline</name>
  <files>src/services/ai.ts, src/routes/webhook.ts</files>
  <action>
1. Update `src/services/ai.ts`:

a. Add import at top:
```typescript
import { ProductType, InsuranceFacts } from '../types/index';
import { insuranceFacts } from '../data/insuranceFacts';
```

b. Update `generateResponse` signature — add optional `productType` parameter:
```typescript
export async function generateResponse(
  contactName: string,
  historyMessages: Array<{ role: string; content: string }>,
  currentMessage: string,
  intent: Intent,
  productType: ProductType | null = null,
): Promise<string>
```

c. Update the `generateResponse` body to pass `productType` to `buildSystemPrompt`:
```typescript
const systemPrompt = buildSystemPrompt(contactName, intent, productType);
```

d. Update `buildSystemPrompt` signature and body:
```typescript
function buildSystemPrompt(contactName: string, intent: Intent, productType: ProductType | null): string
```

Add the product facts block AFTER the existing `intentContext` variable. If `productType` is not null, look up `insuranceFacts[productType]` and call `formatFactsBlock()` to build a facts string. Insert the facts block into the system prompt between the intent context and the rules section.

The updated system prompt structure should be:
```
Você é a Issy, assistente virtual...
Corretor atual: {contactName}
{intentContext}

{if product detected:}
## Informações sobre {productName}
{formatted facts}

{endif}
Regras de comportamento:
- (existing rules unchanged)
```

e. Add a `formatFactsBlock(facts: InsuranceFacts): string` helper function that formats the facts into a readable block:
```
Produto: {productName}
{description}

Coberturas comuns (verifique apólice para valores exatos):
- {coverage1}
- {coverage2}
...

Exclusões comuns:
- {exclusion1}
...

Regras de aceitação típicas:
- {rule1}
...

Notas importantes:
- {note1}
...
```

2. Update `src/routes/webhook.ts`:

a. Add import:
```typescript
import { detectProductType } from '../data/insuranceFacts';
```

b. In `processMessage()`, add product detection BEFORE the `generateResponse` call. Insert after Step 5 (saveMessage) and before Step 6 (generateResponse):
```typescript
// Step 6: Detect product type for facts injection (KNOW-01)
const productType = detectProductType(text);
```

c. Update the `generateResponse` call to pass `productType`:
```typescript
const responseText = await generateResponse(nameToUse, history, text, intent, productType);
```

d. Update the final console.log to include productType:
```typescript
console.log(`[webhook] Responded to ${phone} (intent=${intent}, product=${productType ?? 'none'}, delay=${delaySeconds}s, firstMsg=${firstMsg})`);
```

**IMPORTANT:** Do NOT change the step numbering for existing steps. Only add the new product detection step between existing steps 5 and 6, and renumber from there.
  </action>
  <verify>
    <automated>npx tsc --noEmit --skipLibCheck 2>&1 | head -20</automated>
    <manual>Read ai.ts and confirm buildSystemPrompt includes product facts injection. Read webhook.ts and confirm detectProductType is called before generateResponse.</manual>
  </verify>
  <done>
- `generateResponse` accepts optional `productType` parameter (backwards compatible)
- `buildSystemPrompt` injects product-specific facts when productType is not null
- `formatFactsBlock` produces readable facts from InsuranceFacts object
- `webhook.ts` calls `detectProductType(text)` and passes result to `generateResponse`
- Existing pipeline steps are preserved in correct order
- TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --skipLibCheck` passes with zero errors
2. `src/data/insuranceFacts.ts` exports insuranceFacts with 5 product entries, each having non-empty arrays
3. `src/data/insuranceFacts.ts` exports detectProductType function
4. `src/services/ai.ts` imports insuranceFacts and calls formatFactsBlock when productType is not null
5. `src/routes/webhook.ts` imports detectProductType and passes result to generateResponse
6. No hardcoded R$ values in facts file (all financial values use [ASSESSORIA] marker)
</verification>

<success_criteria>
- Bot with a message containing "saúde" would get a system prompt enriched with health insurance facts
- Bot with a message containing "auto" would get a system prompt enriched with auto insurance facts
- Bot with a general message (no product keyword) would get the existing system prompt without facts injection
- All facts include hedging qualifiers and [ASSESSORIA] placeholders for values requiring confirmation
- TypeScript compiles cleanly; no runtime errors in the happy path
</success_criteria>

<output>
After completion, create `.planning/phases/03-insurance-qa-handoff/03-01-SUMMARY.md`
</output>
