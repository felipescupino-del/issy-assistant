---
phase: 02-core-pipeline
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/routes/webhook.ts
autonomous: false
requirements:
  - CORE-01

must_haves:
  truths:
    - "Broker sends a WhatsApp message and receives an AI-generated Portuguese response in the same thread"
    - "Bot replies using the broker's name (from senderName) on the first message"
    - "Bot demonstrates awareness of previous exchanges by including history in the OpenAI context"
    - "If humanMode is true on the conversation, the bot does NOT respond (human agent is active)"
    - "Response arrives after a visible typing indicator delay of 1-3 seconds — never instant"
    - "Broker receives a fallback message if OpenAI fails — bot never goes silent"
  artifacts:
    - path: "src/routes/webhook.ts"
      provides: "Full end-to-end pipeline: receive → contact upsert → human mode gate → intent classify → load history → save user message → generate AI response → save assistant message → send with typing delay"
      contains: "processMessage"
      min_lines: 40
  key_links:
    - from: "src/routes/webhook.ts"
      to: "src/services/contact.ts"
      via: "upsertContact(phone, senderName)"
      pattern: "upsertContact"
    - from: "src/routes/webhook.ts"
      to: "src/services/conversation.ts"
      via: "getOrCreateConversation(phone) + isHumanMode() gate"
      pattern: "isHumanMode"
    - from: "src/routes/webhook.ts"
      to: "src/services/ai.ts"
      via: "generateResponse(contactName, history, text, intent)"
      pattern: "generateResponse"
    - from: "src/routes/webhook.ts"
      to: "src/services/whatsapp.ts"
      via: "sendTextMessage(phone, responseText, delaySeconds)"
      pattern: "sendTextMessage"
    - from: "src/routes/webhook.ts"
      to: "src/services/history.ts"
      via: "loadHistory() BEFORE saveMessage('user') to prevent history doubling"
      pattern: "loadHistory"
---

<objective>
Wire the complete webhook pipeline by updating processMessage() in src/routes/webhook.ts to call all Phase 2 services in the correct order.

Purpose: This is the final integration step that connects all services built in Plans 01 and 02 into a working end-to-end flow. A broker WhatsApp message enters the webhook and an AI-generated response exits via Z-API — CORE-01 is satisfied.

Output: src/routes/webhook.ts updated; followed by a human verification that the full flow works with a real WhatsApp message.
</objective>

<execution_context>
@/Users/felipescupino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/felipescupino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-pipeline/02-RESEARCH.md
@src/routes/webhook.ts
@src/services/contact.ts
@src/services/conversation.ts
@src/services/history.ts
@src/services/intent.ts
@src/services/ai.ts
@src/services/whatsapp.ts
@src/types/zapi.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite processMessage() with full pipeline orchestration</name>
  <files>src/routes/webhook.ts</files>
  <action>
Replace the contents of src/routes/webhook.ts with the full Phase 2 pipeline. The Express route itself stays the same (immediate 200 + fire-and-forget). Only processMessage() is rewritten.

```typescript
// src/routes/webhook.ts
// Phase 2: Full message pipeline — receive → respond end-to-end (CORE-01)

import { Router } from 'express';
import { parseZApiPayload, ZApiWebhookPayload } from '../types/zapi';
import { upsertContact, isFirstMessage } from '../services/contact';
import { getOrCreateConversation, isHumanMode } from '../services/conversation';
import { loadHistory, saveMessage } from '../services/history';
import { classifyIntent } from '../services/intent';
import { generateResponse } from '../services/ai';
import { sendTextMessage, computeDelaySeconds } from '../services/whatsapp';

const router = Router();

router.post('/', (req, res) => {
  // Acknowledge immediately — Z-API expects a fast 2xx response
  res.json({ status: 'received' });

  // Async processing — fire-and-forget; errors logged, never crash the server
  processMessage(req.body as ZApiWebhookPayload).catch((err) =>
    console.error('[webhook] Erro ao processar mensagem:', err.message),
  );
});

async function processMessage(body: ZApiWebhookPayload): Promise<void> {
  const parsed = parseZApiPayload(body);

  // Guard: ignore non-text messages (image, audio, sticker, etc.)
  // parsed is null for fromMe/group (handled in parseZApiPayload)
  if (!parsed || !parsed.text) return;

  const { phone, text, senderName } = parsed;

  // Step 1: Persist contact — upsert by phone, sync senderName (CORE-02)
  const contact = await upsertContact(phone, senderName);
  const firstMsg = isFirstMessage(contact);

  // Step 2: Human mode gate — check BEFORE any OpenAI call (CORE-04)
  // If humanMode is true, a human agent has taken over. Do not respond.
  const conversation = await getOrCreateConversation(phone);
  if (isHumanMode(conversation)) {
    console.log(`[webhook] Human mode active for ${phone} — skipping bot response`);
    return;
  }

  // Step 3: Classify intent (CORE-03)
  const intent = classifyIntent(text);

  // Step 4: Load history BEFORE saving current user message — prevents doubling (CORE-04)
  const history = await loadHistory(phone);

  // Step 5: Save the incoming user message
  await saveMessage(phone, 'user', text);

  // Step 6: Generate AI response (CORE-05 — fallback handled inside generateResponse)
  const nameToUse = firstMsg ? senderName : contact.name;
  const responseText = await generateResponse(nameToUse, history, text, intent);

  // Step 7: Send response with typing indicator (UX-01)
  // computeDelaySeconds() returns a random int between HUMAN_DELAY_MIN_MS/1000 and HUMAN_DELAY_MAX_MS/1000
  const delaySeconds = computeDelaySeconds();
  await sendTextMessage(phone, responseText, delaySeconds);

  // Step 8: Save assistant response AFTER send succeeds — no phantom messages in history
  await saveMessage(phone, 'assistant', responseText);

  console.log(`[webhook] Responded to ${phone} (intent=${intent}, delay=${delaySeconds}s, firstMsg=${firstMsg})`);
}

export default router;
```

CRITICAL pipeline order rules (from RESEARCH.md):
1. `isHumanMode` check is Step 2 — BEFORE loadHistory or OpenAI. Never after.
2. `loadHistory` is Step 4 — BEFORE `saveMessage(phone, 'user', text)` in Step 5. Prevents current message appearing twice in OpenAI context.
3. `saveMessage(phone, 'assistant', ...)` is Step 8 — AFTER `sendTextMessage` succeeds. No phantom assistant messages on send failure.
4. The `!parsed.text` guard at the top handles image/audio messages — `classifyIntent(null)` would throw without this guard.
  </action>
  <verify>
    <automated>cd /Users/felipescupino/issy-assistant && npx tsc --noEmit 2>&1</automated>
    <manual>Confirm all 6 services are imported; pipeline steps 1-8 are in the correct documented order</manual>
  </verify>
  <done>src/routes/webhook.ts compiles cleanly with all service imports. processMessage() has 8 sequential steps in documented order. npm run dev starts without errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verify — full pipeline works end-to-end with real WhatsApp messages</name>
  <action>
Before starting this checkpoint, confirm prerequisites are met:
  1. .env has real credentials: DATABASE_URL, DIRECT_URL, ZAPI_INSTANCE_ID, ZAPI_INSTANCE_TOKEN, ZAPI_CLIENT_TOKEN, OPENAI_API_KEY
  2. `npx prisma migrate dev --name init` was run (creates tables in Supabase)
  3. `npm run dev` is running and the tunnel (cloudflared) is active
  4. Z-API webhook URL is configured to the tunnel endpoint

No automated action — human must send real WhatsApp messages to verify.
  </action>
  <verify>
    <automated>MISSING — this is a live WhatsApp integration checkpoint requiring real device verification</automated>
    <manual>
1. Run `npm run dev` — confirm server starts and logs "Server listening on port 3000" with no errors.

2. Send a first message from a real WhatsApp (broker phone):
   - Send: "Oi, tudo bem?"
   - Expected: Bot replies in ~2-3 seconds with a greeting in Portuguese that includes your name. Must see typing indicator — never instant.
   - Check terminal: log line shows `[webhook] Responded to {phone} (intent=greeting, delay=Xs, firstMsg=true)`

3. Send a follow-up question:
   - Send: "Quais coberturas tem o plano de saúde básico?"
   - Expected: Bot replies with insurance-related content, professional Portuguese. Must NOT invent specific R$ values or plan names.
   - Check terminal: `firstMsg=false` in the log line.

4. Send a "don't know" query:
   - Send: "Quanto custa um plano odontológico para minha família?"
   - Expected: Bot says it doesn't have the information and offers to escalate to a specialist (CORE-05 fallback).

5. Send a handoff trigger:
   - Send: "Quero falar com um humano"
   - Expected: Bot acknowledges and confirms it will transfer the conversation.

6. Check Supabase Table Editor:
   - `contatos` table: 1 row with your phone number and display name
   - `conversas` table: 1 row with your phone, humanMode=false
   - `mensagens` table: multiple rows alternating role='user' and role='assistant'

Type "approved" if all 6 checks pass, or describe which check failed and what was observed.
    </manual>
  </verify>
  <done>All 6 manual checks pass: typing indicator visible, Portuguese response with broker name on first message, history awareness on follow-up, fallback for unknown queries, database rows created correctly.</done>
</task>

</tasks>

<verification>
TypeScript compilation:
```bash
cd /Users/felipescupino/issy-assistant && npx tsc --noEmit
```

Server starts cleanly:
```bash
cd /Users/felipescupino/issy-assistant && npm run dev
```
Expected: no import errors, no "Cannot find module" errors, Prisma client connects.
</verification>

<success_criteria>
1. `npx tsc --noEmit` passes with zero errors across all Phase 2 files
2. `npm run dev` starts the server cleanly (no crashes on startup)
3. Real WhatsApp message → bot responds in Portuguese with typing indicator delay visible
4. First message uses broker's WhatsApp display name
5. Follow-up question demonstrates conversation history awareness (bot doesn't repeat introduction)
6. Unknown/difficult question triggers the "não tenho essa informação" fallback with escalation offer
7. Database rows created in `contatos`, `conversas`, and `mensagens` tables after the exchange
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-pipeline/02-03-SUMMARY.md` with:
- Files created/modified
- Checkpoint result (approved / issues found)
- Any deviations from the plan
- Notes for Phase 3 (insurance Q&A + handoff)
</output>
